## :mortar_board: 常见算法

### :pencil: 排序算法

> **“选堆快希”**是不稳定的，其他算法是稳定的
>
> 1. **冒泡排序：**每次比较两个元素，如果顺序错误就交换顺序
>
> 2. **选择排序：**每次选择最大或者最小的元素，放在末尾或者头部
>
> 3. **插入排序：**在有序数组内插入指定元素
>
> 4. **快速排序：**找到一个哨兵，将数组划分为两部分，左边部分小于哨兵，右边部分大于哨兵
>
> 5. **归并排序：**采用递归的方法，先对左右半边子序列进行排序，然后合并
>
> 6. **堆排序：**
>
>    节点i的子节点2i/2i+1，父节点i//2
>
>    - 分为建堆，建堆过程需要对所有非叶子节点进行下沉操作；
>    - 出堆则删除头节点，然后将最后一个节点放到头节点再进行下沉操作，插入节点先插入到最后一个位置，然后一直上浮直到比它父节点大（小）
>
> 7. **希尔排序：**根据某一增量将数组分为若干个子序列，然后对每个子序列进行插入排序，直至增量为1
>
> 8. **桶排序：**按照数字个十百千万排序



### :mag_right: 查找算法

> 顺序查找
> 二分查找
> 	注意left<right和left<=right问题
> 斐波那契查找
> 二叉排序查找
> 哈希查找
> 建堆查找



### :open_book: 动态规划

> 利用已有的历史记录（通常采用数组/矩阵存储历史记录）【代码随想录总结】
>
> 1. 构建dp数组以及下标的含义
> 2. 推导递推公式
> 3. dp数组初始化
> 4. 遍历数组
> 5. 打印dp数组来debug

#### 子序列和子串问题

**子串：**必须连续的

**子序列：**可以不连续的

+ [x] 最长公共子序列

  ```python
  # 1. dp[i,j]表示s1[:i+1]和s2[:j+1]两个字符串的最长公共子序列长度
  dp=[[0 for i in range(l1)] for i in range(l2)] # 3.初始化
  # dp初始化需要对dp[0][j]和dp[i][0]进行修正
  for i in range(1,l1): # 4. 遍历
    for j in range(1,l2):
      if s1[i]==s2[j]: # 2. 递推公式
        dp[i][j]=dp[i-1][j-1]+1
      else:
        dp[i][j]=max(dp[i-1][j],dp[i][j-1])
  ```

+ [x] 最长公共子串

  ```python
  # 1. dp[i,j]表示s1[:i+1]和s2[:j+1]两个字符串的最长公共子串的长度
  dp=[[0 for i in range(l1)] for i in range(l2)] # 3.初始化
  # dp初始化需要对dp[0][j]和dp[i][0]进行修正
  res=-1 # 记录最长的长度
  for i in range(1,l1): # 4. 遍历
    for j in range(1,l2):
      if s1[i]==s2[j]: # 2. 递推公式
        dp[i][j]=dp[i-1][j-1]+1
        res=res if res>dp[i][j] else dp[i][j] # 更新最大长度
      else:
        dp[i][j]=0 # 与LCS不同的地方
  ```

+ [x] 最长升序子序列

  ```python
  # 1. dp[i]表示arr[:i]的最长升序子序列
  dp=[1 for _ in range(l)] # 3. 初始化
  for i in range(l): # 4. 遍历
    for j in range(i):
      # 2. 递推公式 dp[i]=max(dp[i],dp[j]+1) 其中j属于[0,i]
      if arr[i]>arr[j]:
        dp[i]=max(dp[i],dp[j]+1)
  ```

+ [x] 最长回文子串

  ```python
  # 1. dp[i,j]=true表示字符串中[i,j]是回文子串
  # 2. dp[i,j] dp[i+1,j-1] and s[i]==s[j]  
  #    讨论i与j的关系,在s[i]==s[j]条件下:
  #        如果j-i<=1 dp[i,j]=true
  #        如果j-i>=2 dp[i,j]=dp[i+1,j-1]
  # 4. 遍历顺序:[i+1,j-1]->[i,j] 左下角到向右上角遍历
  dp=[[0 for _ in range(l)] for _ in range(l)] # 3. 初始化，开始都不是回文子串
  # 也可以将dp[i][i]定义为true
  for i in range(l):
    for j in range(l):
      if s[i]==s[j]:
        if j-i<=1:
          dp[i][j]=1
        else:
          dp[i][j]=dp[i+1][j-1]
  # 5. 遍历寻找最长回文子串
  ```

+ [x] 最大子序列和问题

  ```python
  # 1. dp[i]表示nums的[0,i]最大子序列和
  # 2. 递推公式dp[i]=max(dp[i-1]+nums[i],nums[i])
  ```

  

#### 背包问题

+ [x] 01背包

  每个物体只能用一次

  ```python
  # 1. dp[i,j]表示容量为i的背包装前i个物品最大的价值
  # 如果 j<weight[i]:
  # 2. dp[i,j]=max(dp[i-1,j],dp[i-1,j-weight[i]]+value[i])
  # 优化：dp[j]=max(dp[j],dp[j-weight[i]]+value[i])
  # 优化后遍历顺序：先物品后容量，容量从大到小
  ```

+ [x] 完全背包

  同一个物品可以放多次

  ```python
  # 1. dp[i,j]表示容量为i的背包装前i个物品最大的价值
  # 2. dp[i,j]=max(dp[i-1,j],dp[i-1,j-k*weight[i]]+k*value[i]) # k属于[1,j//weight[i]]
  # 3. 优化：dp[j]=max(dp[j],dp[j-weight[i]]+value[i])
  # 优化后遍历顺序：先物品后容量，容量从小到大
  ```

+ [x] 多重背包

  同一个物品有数量限制

  ```python
  # 1. dp[i,j]表示容量为i的背包装前i个物品最大的价值
  # 2. dp[i,j]=max(dp[i-1,j],dp[i-1,j-k*weight[i]]+k*value[i]) # k属于min{num[i],j//weight[j]}
  # 遍历顺序：先物品后容量
  ```

**01背包题目**

1. [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)：target=sum(arr)，假设targer为背包的最大容量，尽可能利用用书包装arr的item，使得书包装满
2. [最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 构造target

**完全背包**

[随想录](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.md)



### :bookmark_tabs: 贪心算法

> 每一步选择局部最优来达到全局最优
>
> 1. 建立数学模型描述问题
> 2. 把求解问题分为若干个子问题
> 3. 求解每个子问题的最优解
> 4. 合并所有的子问题成为整个问题的最优解

#### 简单

+ [x] [分发饼干](https://leetcode.cn/problems/assign-cookies/)：将饼干和孩子胃口值排序，从胃口值从大到下给孩子发放饼干
+ [x] [K 次取反后最大化的数组和](https://leetcode.cn/problems/assign-cookies/)：对此对数组中最小的进行修改（考虑0的情况，如果数组中都是正数了，有0就反复修改0就可以了）
+ [x] [柠檬水找零](https://leetcode.cn/problems/assign-cookies/)：对三种找零的情况进行讨论，看是否能够满足

#### 中等

+ [x] [摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)：如果上一个是“峰”则贪心得去寻找下一个“谷”，反之亦然；注意初始两个元素相减=0的情况

+ [x] [单调递增的数字](https://leetcode.cn/problems/assign-cookies/)：从左往右遍历，尽可能保留高位；如果遇到逆序则将该位置数减1，后面位置全部设置为9

+ [x] [买卖股票的最佳时间II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)：由于没有购买次数限制，在有利益的时候进行卖出，即`diff=max{0,a[i]-a[i-1]}`，要么不买，要么股票涨价再买

  ```python
  ans = 0;
  for i in range(1,n):
    ans += max(0, prices[i] - prices[i - 1]);
  ```

+ [x] [买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)：（动态规划解题更容易理解）

  ```python
  # dp[i][0]表示第i天交易完成之后手里没有股票的最大利润
  # dp[i][1]表示第i天交易完成之后手里面有股票的最大利润
  # dp[i][0]=max{dp[i-1][0],dp[i-1][1]+prices[i]-fee}
  # dp[i][1]=max{dp[i-1][1],dp[i-1][0]-prices[i]}
  # 返回dp[n-1][0]
  ```

#### 难题

+ [x] [分发糖果](https://leetcode.cn/problems/assign-cookies/)：贪心两次遍历（相当于找“谷”底）
+ [ ]  [跳跃游戏](https://leetcode.cn/problems/jump-game/description/)：从前往后遍历数组，不断更新能到的位置
+ [ ] [无重叠区间](https://leetcode.cn/problems/assign-cookies/)：选出首区间，首个区间就是所有可以选择的区间中右端点最小的那个区间；此后优先选择右边界小的区间



### :open_file_folder: 滑动窗口

>  维护一个满足题目条件的队列

[**最小子串覆盖问题**](https://leetcode.cn/problems/minimum-window-substring/)

给定一个字符串 S 和一个字符串 T，在 S 中找到包含 T 中所有字符的最短子串 

```python
# 滑动窗口的左右指针left,right维护一个窗口
# while right<=l: right开区间
# 	如果s窗口内的包含T中所有字符，left往右边移动直到窗口内不包含所有字符，right再往右移动，不断记录最小窗口
# 标注：需要一个哈希表维护匹配数量问题
```

[**长度最小的子数组问题**](https://leetcode.cn/problems/minimum-size-subarray-sum/)

给定一个正整数数组和一个目标值，找到一个连续的子数组，使得子数组的和大于等于目标值，并且子数组的长度最小

```python
# 滑动窗口的左右指针left,right维护一个窗口
# while right<=l: right开区间
# 	如果窗口内的元素和大于target，left往右边移动直到和小于target，right再往右移动，不断记录最小窗口
```

**至多包含两个不同字符的最长子串问题**

给定一个字符串，找到一个最长的子串，使得这个子串中最多包含两个不同的字符

```python
# 滑动窗口的左右指针left,right维护一个窗口
```

[**字符串的排列问题**](https://leetcode.cn/problems/permutation-in-string/)

给定两个字符串 s1 和 s2，判断 s2 是否包含 s1 的排列，也可以用回溯法

```python
# 遍历s2中每个长度为len(s1)的子串，如果子串的每个字符统计的数量和s1统计的相同，那么就存在
# 如果遍历完所有s2的子串都不存在，则不存在
```

**最大连续 1 的个数 III 问题**

给定一个二进制数组和一个整数 k，找到其中最长的连续 1 的子数组，使得该子数组中最多有 k 个 0

```python
# 滑动窗口的左右指针left,right维护一个窗口
```



###  :bookmark: 回溯算法

> 撤销上一步操作，尝试下一个可能
> def backtracking(args,start_index,path,res):
>  if end condition：
>  	res.append(path) # path是每一个分支结果，res是所有的结果
>  for i in each layer:
>   path.append(i)
>   backtracking(args,i+1,path,res)
>   path.pop() # 回溯



### :blue_book:树算法

#### 优先队列

[最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/discussion/)



### :closed_book: 树算法

> 1. 深度优先遍历
> 2. 广度优先遍历
> 3. 优先队列



### :green_book: 图算法

> 1. 深度优先遍历
> 2. 广度优先遍历
> 3. 并查集
> 4. 最短路径
>    - 单源最短路径
>    - 多源最短路径
> 5. 最小生成树



### :books: 参考

[参考代码随想录](https://github.com/youngyangyang04/leetcode-master)
