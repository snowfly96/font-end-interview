

### :open_book: 浏览器

#### 浏览器工作原理？

> 浏览器是一种典型的客户端应用程序，其浏览器工作的基本原理如下：
>
> 1. **用户输入并解析URL**: 用户在浏览器地址栏输入URL（统一资源定位符）时，浏览器会将该URL转换为IP地址（DNS查询，例如：[www.example.com](http://www.example.com/) -> 93.184.216.34），以便将请求发送到正确的服务器（该过程会查看是否有本地缓存）
>
>    > + DNS解析过程原理
>    > + 网络层原理
>
> 2. **建立连接：**一旦浏览器知道服务器的IP地址，它会使用TCP协议建立与服务器的连接。
>
>    > + 网络层原理
>    > + 传输层原理
>
> 3. **发送请求：**一旦连接建立，浏览器将发送一个HTTP/HTTPS请求到服务器，请求特定的资源（例如HTML文件、图像文件等）。
>
>    > + 应用层原理：http协议的请求步骤
>    > + 如何确保数据安全可靠传输
>
> 4. **接收响应：**服务器接收到请求后，会返回一个HTTP/HTTPS响应，其中包含请求资源的内容和元数据（例如响应状态码、头信息等）。
>
>    > + 响应请求的原理
>
> 5. **解析HTML：**一旦浏览器收到响应，它会将响应内容解析为HTML，CSS和JavaScript等各种格式的数据。
>
>    > + 编译原理：词法分析、语法分析和构建DOM树和css树
>
> 6. **构建DOM树/CSSOM树：**浏览器使用解析的HTML构建DOM（文档对象模型）树，它表示了页面的层次结构。
>
>    > + 使用html构建dom树/css构建cssOM树
>
> 7. **渲染页面：**一旦DOM树构建完成，浏览器会使用CSS对其进行样式化，然后将其渲染到屏幕上。
>
>    > + 构建渲染渲染树
>    > + 理解重绘和重排的概念
>
> 8. **执行JavaScript：**如果HTML中包含JavaScript代码，浏览器将执行该代码，并在DOM树中进行修改或添加。
>
>    > + js引擎原理
>
> 9. **处理用户输入：**浏览器还负责处理用户输入，例如单击链接或提交表单等操作。
>
>    > + 异步请求等等
>
> 10. **存储缓存：**浏览器还可以将页面内容缓存到本地，以便在下次访问相同页面时更快地加载内容。
>
>     > + 浏览器缓存等等
>
> 浏览器还有很多复杂的细节和特性，如HTTP缓存、Cookie管理、跨站点脚本攻击（XSS）防护等。



#### HTTP请求响应步骤

> 1. 建立TCP连接（3次握手）
> 2. 客户端向服务器发送请求行（请求方式、请求URL和协议版本）
> 3. 客户端向服务器发送请求头（请求服务器主机地址、缓存控制、连接状态、语言、编码方式、压缩方式等）
> 4. 如果是POST请求，客户端会继续发送请求体内容；如果是GET请求则没有请求体
> 5. 服务器接收到请求之后，返回请求行（版本号和状态码）
> 6. 返回请求头（应用程序版本、正文内容长度、语言，编码方式，压缩方式等）
> 7. 返回请求体（响应内容：html文档、资源、图片等等）
> 8. 断开TCP连接（四次挥手）

#### 请求行、请求头和请求体分开发送

> 1. 请求行中包含请求方式、请求URL和协议版本，是基本的请求信息，不需要太大，单独出来发送能够使得服务器快速了解客户端的请求，提高效率
> 2. 请求头分离出来，可以减少请求体的大小，同时还能帮助服务器了解客户端状态，提高效率
> 3. 减少请求体大小，降低传输失败情况，提高传输的稳定性

#### 如何保证数据能够完整、正确和可靠的传输？

> 1. **使用校验和：**发送方在数据发送之前添加校验字段，接收方接受后进行校验对比
> 2. **使用序列号：**对接收到的数据进行重排，确保数据完整性
> 3. **确认应答机制：**接收方在收到消息并确认无误后发送确认消息
> 4. **重传机制：**对错误或者丢失的包进行重传
> 5. **加密技术：**对传输的数据进行加密，确保数据安全可靠
> 6. **数字证书：**对发送方数据进行签名，接收方验证发送方是否属于可靠机构

#### 什么是数字签名？

> 用于验证消息完整性、真实性和不可否认性的技术。私钥用于加密，公钥用于验证
>
> 1. 发送方生成私钥和公钥
> 2. 用私钥进行数据加密
> 3. 将加密后的数据和公钥一同发送给接受方
> 4. 接收方验证签名



#### 常见浏览器攻击？

> 浏览器攻击是指利用浏览器漏洞对用户进行攻击的一种方式。常见的浏览器攻击方式：
>
> 1. **跨站脚本攻击（XSS-*Cross-Site Scripting*）**：攻击者利用网站漏洞，向客户端网页中注入恶意脚本，当用户访问这个页面时，恶意脚本会被执行，攻击者可以通过这种方式窃取用户的敏感信息。
>
>    > XSS攻击通常分为以下三种类型：
>    >
>    > 1. **存储型XSS：**攻击者将恶意脚本代码提交到Web应用程序的数据库中，当其他用户访问该Web应用程序时，恶意脚本代码会被从数据库中获取并执行。
>    > 2. **反射型XSS：**攻击者将恶意脚本代码作为参数提交给Web应用程序，Web应用程序在返回响应时，将恶意脚本代码反射回浏览器并执行。
>    > 3. **DOM型XSS：**攻击者通过修改Web应用程序的DOM元素，向其中插入恶意脚本代码，并使得该恶意脚本代码在被浏览器解析时执行。
>
> 2. **点击劫持攻击：**攻击者利用透明iframe将一个合法的网页覆盖在一个恶意网页上，当用户在看到的合法网页上进行点击操作时，实际上是在进行恶意网页上的操作，攻击者可以通过这种方式控制用户的操作。
>
> 3. **跨站请求伪造（CSRF攻击-Cross-Site Request Forgery）：**攻击者通过某种方式让用户在登录状态下访问一个恶意网页，这个网页会向用户正在访问的网站发送请求，从而实现攻击目的。
>
> 4. **代码注入攻击：**攻击者通过输入恶意代码，对浏览器或服务器进行攻击，这种攻击方式常常被用于窃取用户的敏感信息。
>
> 5. **URL欺骗攻击：**攻击者将一个看似正常的URL欺骗用户点击，实际上却指向一个恶意网站，从而实现攻击目的。

#### Https认证授权

> https是建立在tcp链接之后，进行tls握手协议，完成握手之后，服务器会发送数字证书给客户端，客户端验证证书的有效性，在确认服务器身份之后双方才会进行通信。在TLS握手过程中，认证授权的步骤是**验证服务器的数字证书**，确认其**是否被信任机构签发**，**是否过期**等信息，确保客户端连接到的是**正确的服务器**，避免**中间人攻击**等安全问题。
>
> **中间人攻击：**
>
> + 攻击者通过截获网络通信数据，在通信的两端之间进行欺骗，使得通信的双方认为他们正在直接通信，实际上中间人在通信的过程中进行监听、篡改、替换等恶意操作，从而窃取数据、伪造信息或者控制通信内容。攻击者可以通过多种方式实现中间人攻击，包括ARP欺骗、DNS欺骗、WiFi钓鱼等
> + arpspoof是一种中间人攻击工具，可以欺骗目标主机的ARP表，将其通信流量重定向到攻击者所在的机器上，从而实现窃取数据、篡改信息等恶意行为

#### JS执行原理？

> 1. **词法分析：**JavaScript 引擎会将 JavaScript 代码分解成一个个词法单元，如变量名、函数名、操作符等。
> 2. **语法分析：**JavaScript 引擎会将词法单元转化成语法树，根据语法规则进行语法分析，判断代码是否符合语法规则。
> 3. **编译：**JavaScript 引擎将语法树编译成字节码。
> 4. **解释执行：**JavaScript 引擎将字节码解释成机器码，并执行代码。

#### JS单线程机制？

> JavaScript 是一种单线程的脚本语言，这意味着它**只有一个主线程来处理所有的任务**。以下是 JavaScript 单线程的原理：
>
> 1. **任务队列：**JavaScript 引擎会将任务分为两类：同步任务和异步任务。同步任务会立即执行，而异步任务则会被放入任务队列中，等待执行。
> 2. **事件循环：**JavaScript 引擎会不断地循环检查任务队列，如果任务队列中有任务，则会将任务取出并执行。如果任务队列为空，则 JavaScript 引擎会等待任务的到来，直到有任务时再继续执行。
> 3. **单线程执行：**由于 JavaScript 是单线程的，因此同一时间只能执行一个任务。如果当前任务没有执行完毕，那么其他任务就必须等待。
> 4. **非阻塞 I/O：**为了避免任务的阻塞，JavaScript 引擎通常使用非阻塞 I/O 操作，当遇到需要等待的操作（如 Ajax 请求或定时器等），JavaScript 引擎会将其放入任务队列中，并立即执行下一个任务，以充分利用时间。
>
> JavaScript 单线程的优点在于可以避免线程同步的问题，简化了程序的设计和实现。同时，单线程模型也存在缺点，比如无法充分利用多核 CPU，以及某个任务阻塞会导致整个线程被阻塞等问题。

#### JS异步机制？

> JavaScript 是一门基于事件驱动的编程语言，因此异步编程是其核心特性之一。JavaScript 异步机制可以通过以下方式实现：
>
> 1. **回调函数：**回调函数是 JavaScript 中实现异步编程最常用的方式。在异步操作完成后，JavaScript 引擎会调用相应的回调函数来处理操作结果。
> 2. **Promise：**Promise 是一种解决回调函数嵌套的问题的机制。它通过链式调用的方式，将多个异步操作组合在一起，形成一个异步操作序列，从而避免了回调函数嵌套的问题。
> 3. **async/await：**async/await 是 ES2017 中引入的新特性，它可以使异步代码的编写更加简单和易读。async/await 基于 Promise 实现，通过使用 async 关键字定义异步函数，以及使用 await 关键字等待异步操作的结果，使得异步代码的编写更加类似于同步代码。
>
> 在 JavaScript 中，异步操作通常是由事件循环机制来处理，JavaScript 引擎会将异步操作放入事件循环中异步队列中，并在任务队列中等待执行。当异步操作完成后，JavaScript 引擎会将其对应的回调函数放入事件循环的异步队列中，并等待任务队列中的其他任务执行完毕后再执行回调函数。
>
> 异步操作会先被放入事件循环的异步队列中，当异步操作完成时，其对应的回调函数会被放入回调队列中等待执行。当主线程执行完任务队列中的所有同步任务后，就会去检查异步队列中是否有任务可执行，如果有则在其异步操作完成之后，将其对应的回调函数放入回调队列中等待执行，这个过程就是事件循环。因此，异步操作和其回调函数虽然都和任务队列有关，但是它们分别属于不同的队列

#### 什么是非阻塞I/O?

> JavaScript 是单线程的，如果 I/O 操作是阻塞的，那么程序就会在 I/O 操作完成之前被阻塞，无法执行其他任务。为了解决这个问题，JavaScript 使用了非阻塞 I/O，它的基本原理是：**当执行一个 I/O 操作时，JavaScript 引擎会将其放入任务队列中，并在完成I/O操作之后，将结果返还给事件队列，等待其他事件执行完毕之后在执行I/O对应的回调函数**
>
> 非阻塞 I/O 的另一个重要特点是回调函数。当一个异步 I/O 操作完成后，JavaScript 引擎会调用对应的回调函数来处理结果。这个回调函数可以是一个匿名函数，也可以是一个已经定义好的函数。这种回调函数的使用方式被称为回调函数式编程（Callback-style Programming），是 JavaScript 编程中常用的一种编程模式。
>
> 非阻塞 I/O 在 JavaScript 中被广泛应用，比如 **Ajax 请求、文件读写、网络通信**等。它能够提高程序的执行效率和响应速度，使得 JavaScript 在客户端和服务端的开发中得到广泛应用。

#### 浏览器的进程结构

> 浏览器是个多进程结构
>
> 1. **浏览器主进程：**控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与浏览器其他进程负责协调工作
> 2. **缓存进程**：对浏览器的缓存进行管理
> 3. **网络进程：**发起网络请求 
> 4. **渲染器进程：**渲染Tab  有可能会为每个标签页是一个渲染进程
> 5. **GPU进程：**渲染，加速栅格化生成 
> 6. **插件进程：**内置插件

#### 渲染进程

> 下面说下渲染进程的过程
>
> 1. 浏览器通过网络请求后获取html数据，通过tcp传给渲染器进程
> 2. DOM - 主线程将html解析构造DOM树
> 3. style - 样式计算
> 4. layoutTree - dom+style 根据dom树和样式生成layoutTree
> 5. paint -绘制  通过遍历 Layout Tree生成绘制顺序表
> 6. laryer - 布局  然后根据主进程将layoutTree 和绘制信息表传给合成器线程
> 7. 合成器线程  - 将得到的信息分图层分成更小的图块
> 8. 栅格线程    -    将更小的图块进行栅格化raster，返还给合成器线程draw quads图块信息  存储在GPU中
> 9.  frame 合成器将栅格线程返回的图块合成帧交给浏览器进程
> 10. 浏览器进程  收到一帧的图像后传给GPU进行渲染

#### 浏览器线程

> 浏览器中的线程通常可以分为以下几类：
>
> 1. UI线程（User Interface thread）：这个线程负责处理用户界面操作，例如处理鼠标点击、键盘输入、窗口调整等。
> 2. JS线程（JavaScript thread）：这个线程负责执行JavaScript代码，并处理JavaScript引擎的事件循环。
> 3. 渲染线程（Rendering thread）：这个线程负责将HTML、CSS和JavaScript转换为可视化的网页元素，并渲染到屏幕上。
> 4. 后台线程（Background thread）：这个线程负责处理后台任务，例如网络请求、数据库操作、定时器等。
> 5. 定时器线程（Timer thread）：这个线程负责处理JavaScript定时器的触发事件。
> 6. 工作线程（Worker thread）：这个线程负责处理Web Worker的任务，这些任务通常是在后台执行的较为耗时的操作。
> 7. GPU线程（GPU thread）：这个线程负责处理GPU相关的操作，例如图形渲染、图像合成等。



#### 浏览器缓存

> 浏览器缓存，就是将一个已经请求过的web资源（如js、html、图片等数据）拷贝存储在浏览器中
>
> 强制缓存（直接本地取副本）和协商缓存（想向服务器询问资源是否过期/更新）
>
> 1. 降低服务器压力
> 2. 减少网络宽带消耗
> 3. 减少延迟
>
> **Cookie：** 由于http协议的无状态性，cookie用于记录和保存用户的行为状态，如判断用户是否已经登录、上一次访问到网页那个区域等等，方便网页更加个性化的推荐（有效期内一直有效）
>
> [cookie、session和token区别](https://juejin.cn/post/6844904034181070861)
>
> [cookie、session和token](https://segmentfault.com/a/1190000017831088)
>
> sessionStorage在网页刷新后快速显示页面（页面关闭之后无效），localStorage在系统意外关机后快速加载页面（始终有效）



#### 调试工具

[B站浏览器调试工具](https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&vd_source=084728306193898208d80f40ece2975b)



#### 性能指标

> 1. 首屏绘制：输入网址浏览器开始显示内容时间
> 2. 首屏内容绘制：输入网址浏览器绘制文本、图片等内容的时间
> 3. 可交互时间：第一次到达可交互状态的时间点
> 4. 最大内容绘制：页面主要内从首次出现在屏幕上时间
> 5. 首次有效绘制：可视区最大元素出现的时间
